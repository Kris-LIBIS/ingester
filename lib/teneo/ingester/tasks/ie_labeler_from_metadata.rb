# frozen_string_literal: true

require 'libis/tools/extend/hash'

require_relative 'base/task'

module Teneo
  module Ingester
    module Tasks

      class IeLabelerFromMetadata < Teneo::Ingester::Tasks::Base::Task

        taskgroup :pre_ingest

        description 'Generate IE item labels and names based on a pattern and metadata fields.'

        help_text <<~STR
          Rename the IE item object based on a regular expression.

          By default the File item filename is used to label files, but this can be changed with the 'value' parameter.

          First of all the value is matched against a regular expression defined in the 'pattern' parameter. This regex
          should define groups that will be used to extract the common and unique pieces of the file property. Based on
          the result of the regex matching and using references to the regex groups (m1, m2, ... ), a new label will be
          generated by interpolating the given string in the 'label' parameter. Besides regex groups the metadata fields
          title(s), creator(s), subject(s), date(s), identifier(s) and source(s) are available for the interpolation as
         'title', 'titles', 'creator', 'creators', etc.

          Optionally a different string for the item's name can be added in 'name'.
        STR

        parameter pattern: nil,
                  description: 'Regular expression for matching; nothing happens if nil.'
        parameter value: 'name',
                  description: 'The item property to be used for the matching.'
        parameter label: nil,
                  description: 'String with interpolation placeholders for new value of item label property.'
        parameter name: nil,
                  description: 'String with interpolation placeholders for new value of item name property.'

        recursive true
        item_types Teneo::Ingester::IntellectualEntity

        protected

        def process(item, *_args)
          pattern = parameter(:pattern)
          if pattern && !pattern.blank?
            value = item.evaluate(parameter(:value))
            m = Regexp.new(pattern).match(value)
            return if m.nil?
            vars = get_metadata_fields(item).merge(match_to_hash(m))
            if parameter(:label)
              file_label = item.interpolate(parameter(:label), vars)
              debug 'Assigning label %s', item, file_label
              item.label = file_label
            end
            if parameter(:name)
              file_name = item.interpolate(parameter(:name), m, vars)
              debug 'Renaming to %s', item, file_name
              item.name = file_name
            end
            item.save!
          end
          item
        end

        def get_metadata_fields(item)
          metadata = item.metadata_record
          return {} unless metadata
          xml = Libis::Metadata::DublinCoreRecord.new(metadata.data)
          {
              title: xml.title.content,
              titles: xml.get_nodes('title').map(&:content).join(', '),
              creator: xml.creator.content,
              creators: xml.get_nodes('creator').map(&:content).join(', '),
              subject: xml.subject.content,
              subjects: xml.get_nodes('subject').map(&:content).join(', '),
              date: xml.date.content,
              dates: xml.get_nodes('date').map(&:content).join(', '),
              identifier: xml.identifier.content,
              identifiers: xml.get_nodes('identifier').map(&:content).join(', '),
              source: xml.source.content,
              sources: xml.get_nodes('source').map(&:content).join(', '),
          }.cleanup
        end

      end

    end
  end
end
